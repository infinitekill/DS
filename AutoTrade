local plr = game.Players.LocalPlayer
local gui = plr.PlayerGui
local vim = game:GetService'VirtualInputManager'
local Trades = workspace.CurrentTrades
local rs = workspace.GameEvents
local rs2 = workspace.GameFunctions
local inv = plr.MemoryCard.Tokens

local function acceptingCheck()
    for i,v in pairs(Trades:GetChildren()) do
        if v.Name == plr.Name and v.Creator.Value == PlayerToTradeWith then
            return v
        end
    end
end
local function sendingCheck()
    for i,v in pairs(Trades:GetChildren()) do
        if v.Name == PlayerToTradeWith and v.Creator.Value == plr.Name then
            return true
        end
    end
end
local noTrade = false
if Action == 'Accepting' then
    while true do
        if acceptingCheck() then
            task.spawn(function()
                while true do
                    if not acceptingCheck() then
                        noTrade = true
                        break
                    end
                    task.wait()
                end
            end)
            rs2.AcceptTrade:InvokeServer(acceptingCheck())
            while true do
                if gui:FindFirstChild('PromptGui') and gui.PromptGui:FindFirstChild('Prompt_Frame') and gui.PromptGui.Prompt_Frame:FindFirstChild('YesBtn') then
                    while gui:FindFirstChild('PromptGui') and gui.PromptGui:FindFirstChild('Prompt_Frame') and gui.PromptGui.Prompt_Frame:FindFirstChild('YesBtn') do
                        local x = gui.PromptGui.Prompt_Frame.YesBtn
                        vim:SendMouseButtonEvent(x.AbsolutePosition.X+x.AbsoluteSize.X/2,x.AbsolutePosition.Y+50,0,true,x,1)
                        vim:SendMouseButtonEvent(x.AbsolutePosition.X+x.AbsoluteSize.X/2,x.AbsolutePosition.Y+50,0,false,x,1) 
                        task.wait()
                    end
                    break
                end
                task.wait()
            end
            while true do
                if noTrade then
                    noTrade = false
                    break
                end
                task.wait()
            end
        end
        task.wait()
    end
elseif Action == 'Sending' then
    while true do
        if not sendingCheck() then
            if OfferType then
                OfferDinoList = {}
                local count = 0
                for i,v in pairs(inv:GetChildren()) do
                    if string.find(v.Name, OfferType) then
                        count += 1
                        table.insert(OfferDinoList, v.Name) 
                        if count == 5 then break end
                    end
                end
            end
            if RequestType then
                RequestDinoList = {}
                local count = 0
                for i,v in pairs(game.Players[PlayerToTradeWith].MemoryCard.Tokens:GetChildren()) do
                    if string.find(v.Name, RequestType) then
                        count += 1
                        table.insert(RequestDinoList, v.Name) 
                        if count == 5 then break end
                    end
                end
            end
            rs.SendTrade:FireServer(PlayerToTradeWith, OfferDinoList, RequestDinoList)
            while true do
                if gui:FindFirstChild('PromptGui') and gui.PromptGui:FindFirstChild('Prompt_Frame') and gui.PromptGui.Prompt_Frame:FindFirstChild('YesBtn') then
                    while gui:FindFirstChild('PromptGui') and gui.PromptGui:FindFirstChild('Prompt_Frame') and gui.PromptGui.Prompt_Frame:FindFirstChild('YesBtn') do
                        local x = gui.PromptGui.Prompt_Frame.YesBtn
                        vim:SendMouseButtonEvent(x.AbsolutePosition.X+x.AbsoluteSize.X/2,x.AbsolutePosition.Y+50,0,true,x,1)
                        vim:SendMouseButtonEvent(x.AbsolutePosition.X+x.AbsoluteSize.X/2,x.AbsolutePosition.Y+50,0,false,x,1) 
                        task.wait()
                    end
                    break
                end
                task.wait()
            end
            while true do
                if sendingCheck() then
                    break
                end
                task.wait()
            end
        end
        task.wait()
    end
end
            
    
